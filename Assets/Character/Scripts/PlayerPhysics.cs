using UnityEngine;
using System.Collections;

public class PlayerPhysics : MonoBehaviour {

    #region Public Variables
    // Player Movement
    public float gravity = 1.5f;            // force of gravity
    public float maxSpeed = .3f;            // the fastest the player can move
    public float acceleration = 1;          // how fast to interpolate to maxSpeed
    public float jumpHeight = .6f;          // how high can we jump
    public LayerMask collisionMask;         // what will we collide with
    #endregion

    #region Private Variables
    // Checks
    private bool isGrounded = false;        // are we on the ground
    private bool movementStoppedX = false;  // has our movement forcefully been stopped on the x-axis
    private bool idle = false;              // are we standing still
    private bool facingRight = true;        // what direction are we facing

    // used for movement
    private float deltaX;   // holds all movement in the x-direction
    private float deltaY;   // holds all movement y-direction

    // holds the direction of gravity
    private Vector2 gravityDir; // (-1 = left || 0 = none || 1 = right, -1 = down || 0 = none || 1 = up)

    //Used to determine if we are near a ground or a ceiling
    private Transform groundCheck;                  // A position marking where to check if the player is grounded.
    private const float k_groundedRadius = .2f;     // Radius of the overlap circle to determine if grounded
    // THESE TWO NOT USED FOR NOW, BUT IF WE DID CROUCHING, IT WOULD BE REALLY USEFUL
    private Transform ceilingCheck;                 // A position marking where to check for ceilings
    private const float k_ceilingRadius = .01f;     // Radius of the overlap circle to determine if the player can stand up

    #region Collision Variables
    // used in collisions
    private BoxCollider2D collider; // the box collider on the player
    private Vector2 p;              // our current position
    private Vector3 s;              // the size of our collider
    private Vector3 o;              // the center of our collider

    // used if we have scaled the collider
    private Vector3 originalSize;   // holds the original size of the collider
    private Vector3 originalOffset; // holds the original offset of the collider
    private float colliderScale;    // how much have we scaled by

    // how many rays should we cast for collision detection
    private const int k_collisionsDivisionX = 3;    // number of rays cast for top/bottom collisions
    private const int k_collisionsDivisionY = 3;    // number of rays cast for left/right collisions

    private float skin = .005f; // Tiny bit of space above all objects to make sure we stay above them

    // used for all collisions
    private RaycastHit2D hit;   // Holds hit info generated by a Physics2D.Raycast
    #endregion

    /*
    // NOTE #1: doesn't work for vertical. need to do a correction with some vertical offset
    // used to correct movement if standing on a horizontal moving platform
    private Transform platform;                             // the platform we are standing on
    private Vector3 platformPosPrev;                        // the platform's previous position
    private Vector3 deltaPlatformPos;                       // the change in distance between the platform's positions
    */


    #endregion

    void Start()
    {
        gravityDir = new Vector2(0, -1);  // set default gravity to down with no horizontal gravity

        groundCheck = transform.Find("GroundCheck");
        ceilingCheck = transform.Find("CeilingCheck");

        collider = GetComponent<BoxCollider2D>();
        // If we every scale the collider to not be 1,1,1, the below will be useful
        colliderScale = transform.localScale.x; // assumes the scale for the collider is equal in all dimensions
        originalSize = collider.size;
        originalOffset = collider.offset;
        SetCollider(originalSize, originalOffset);
    }

    // On a fixed interval, check if the player is on the ground
    private void FixedUpdate()
    {
        isGrounded = false;

        // The player is grounded if a circlecast to the groundcheck position hits anything designated as ground
        // This can be done using layers instead but Sample Assets will not overwrite your project settings.
        Collider2D[] colliders = Physics2D.OverlapCircleAll(groundCheck.position, k_groundedRadius, collisionMask);
        for (int i = 0; i < colliders.Length; i++)
        {
            if (colliders[i].gameObject != gameObject)
                isGrounded = true;
        }
    }

    // Applies movement to the player based on input
    // @param hDir - the horizontal direction taken in by input
    // @param jump - check if the player has input that they want to jump
    public void Move(float hDir, bool jump)
    {
        float targetSpeed = hDir * maxSpeed;        // the speed value we are moving towards, used to handle accelerating the player
        // If we've forcefully be stopped by a collision in the x-direction, reflect that in the actual movement
        if (movementStoppedX)
        {
            targetSpeed = 0;
            deltaX = 0;
        }

        // accelerate the player
        deltaX = IncrementTowards(deltaX, targetSpeed, acceleration);

        // If the input is moving the player right and the player is facing left...
        if (hDir > 0 && !facingRight)
            Flip(); // ...flip the player.
        // Otherwise if the input is moving the player left and the player is facing right...
        else if (hDir < 0 && facingRight)
            Flip(); // ...flip the player.

        // Jump
        if (isGrounded && jump)
        {
            isGrounded = false; // the player is no longer on the ground
            // apply the jump in the appropriate direction according to gravity
            if (gravityDir.x != 0)
                deltaX += jumpHeight * -gravityDir.x;
            if (gravityDir.y != 0)
                deltaY += jumpHeight * -gravityDir.y;
        }

        // if the player is not inputting to move, we are idle
        if (deltaX == 0)
            idle = true;
        else
            idle = false;

        ApplyPhysics();     // apply all physics that would alter movement

        // holds the final transform after all the calculations
        Vector2 finalTransform = new Vector2(deltaX, deltaY);
        // actually move the character
        transform.Translate(finalTransform);
    }

    // apply all physics
    public void ApplyPhysics()
    {
        ApplyGravity();

        /*
        // SEE NOTE #1
        // update how far the platform has moved if standing on one
        if (platform)
            deltaPlatformPos = platform.position - platformPosPrev;
        else
            deltaPlatformPos = Vector3.zero;
        */

        HandleCollisions();

        /*
        // SEE NOTE #1
        // adjust movement for platforms
        if (platform)
        {
            deltaX += deltaPlatformPos.x;
        }
        */
    }

    // Handles all collisions
    public void HandleCollisions()
    {
        p = transform.position;

        #region Vertical Collision Detection
        // Check collisions above and below
        for (int i = 0; i < k_collisionsDivisionX; i++)
        {
            // what direction are we checking for collisions
            float dirY = Mathf.Sign(deltaY); // 1 = up, -1 = down
            // split apart the rays staring from the left of the box to the right of the box
            float x = (p.x + o.x - s.x / 2) + s.x / (k_collisionsDivisionX - 1) * i;
            float y = p.y + o.y + s.y / 2 * dirY; // top or bottom edge of collider

            Vector2 rayOrigin = new Vector2(x, y);  // set the ray's origin point

            // THE FOLLOWING IS USED FOR DEBUGGING
            Ray2D ray = new Ray2D(rayOrigin, new Vector2(0, dirY));
            Debug.DrawRay(ray.origin, ray.direction, Color.red);

            // set up our RaycastHit2d
            //@params: the origin we set up earlier
            //         the direction determined by our calculation earlier
            //         only check as far as how far the player would move
            //         the collisionLayerMask
            hit = Physics2D.Raycast(rayOrigin, new Vector2(0, dirY), Mathf.Abs(deltaY), collisionMask);
            //did we generate a hit
            if (hit)
            {
                // assign the moving platform that we're on if we're above one
                if (hit.collider.tag == "MovingPlatform" && dirY == -1)
                {
                    // SEE NOTE #1
                    //platform = hit.transform;
                    //platformPosPrev = platform.position;
                    transform.parent = hit.transform;
                }
                else
                    transform.parent = null;

                // the distance between the raycast and the hit
                float dst = Vector2.Distance(rayOrigin, hit.point);

                // Stop vertical movement
                // If we're very close, but not quite within grace distance, keep moving closer very slowly until we are
                if (dst > skin)
                    deltaY = dst * dirY - skin * dirY;
                else
                    deltaY = 0;

                isGrounded = true;  // we are on the ground now
                break;
            }
            // if there's no collision, we're not on a platform
            else
                // SEE NOTE #1
                // platform = null;
                transform.parent = null;
        }
        #endregion

        #region Horizontal Collision Detection
        movementStoppedX = false;    // reset movementStopped
        // Check collisions left and right
        for (int i = 0; i < k_collisionsDivisionY; i++)
        {
            // what direction are we checking for collisions
            float dirX;
            // if we're idle, check in the direction we're facing
            if(idle)
            {
                if (facingRight)
                    dirX = 1;
                else
                    dirX = -1;
            }
            // else check in whatever direction we're moving
            else
                dirX = Mathf.Sign(deltaX); // 1 = right, -1 = left
            float x = p.x + o.x + s.x / 2 * dirX; // left or right edge of collider
            // split apart the rays staring from the top of the box to the bottom of the box
            float y = p.y + o.y - s.y / 2 + s.y / (k_collisionsDivisionY - 1) * i;

            Vector2 rayOrigin = new Vector2(x, y);          // set the ray's origin point
            
            // THE FOLLOWING IS USED FOR DEBUGGING
            Ray2D ray = new Ray2D(rayOrigin, new Vector2(dirX, 0));
            Debug.DrawRay(ray.origin, ray.direction, Color.red);

            // set up our RaycastHit2d
            //@params: the origin we set up earlier
            //         the direction determined by our calculation earlier
            //         only check as far as how far the player would move
            //         the collisionLayerMask
            hit = Physics2D.Raycast(rayOrigin, new Vector2(dirX, 0), Mathf.Abs(deltaX), collisionMask);
            //did we generate a hit
            if (hit)
            {
                // the distance between the raycast and the hit
                float dst = Vector2.Distance(rayOrigin, hit.point);

                // Stop horizontal movement after coming within a grace distance with the collider
                if (dst > skin)
                    deltaX = dst * dirX - skin * dirX;
                else
                    deltaX = 0;

                movementStoppedX = true; // we stopped moving because we hit something
                break;
            }
        }
        #endregion

        #region Diagonal Collision Detection
        // Check collisions diagonally (to land on edges)
        if (!isGrounded && !movementStoppedX)
        {
            Vector3 playerDir = new Vector3(deltaX, deltaY);    // what direction are we going at the moment
            // find the corner that we're using
            Vector2 center = new Vector2(p.x + o.x + s.x / 2 * Mathf.Sign(deltaX), p.y + o.y + s.y / 2 * Mathf.Sign(deltaY));

            // DRAW THE RAY IN DEBUG
            Debug.DrawRay(center, playerDir.normalized, Color.yellow);

            // normalize because we're using a direction
            Ray2D ray = new Ray2D(center, playerDir.normalized);
            // use pythagorean theorem to find the distance of the ray
            if (Physics2D.Raycast(center, playerDir.normalized, Mathf.Sqrt(deltaX * deltaX + deltaY * deltaY), collisionMask))
            {
                isGrounded = true;
                deltaY = 0;
            }
        }
        #endregion
    }

    // Handles the acceleratation and deceleration of the object
    // @param current - the speed we are currently moving at
    // @param target - the speed we want to be at
    // @param accel - the rate at which we should increment the objects's position
    private float IncrementTowards(float current, float target, float accel)
    {
        // if we're moving at the target speed, we've achieved the speed we wanted
        if (current == target)
            return current;
        else
        {
            // what direction to go to get closer to the target
            float dir = Mathf.Sign(target - current);
            current += accel * Time.deltaTime * dir;
            // if we haven't reached out target speed, return out current speed
            // but if we've gone to far, return the target speed
            return (dir == Mathf.Sign(target - current)) ? current : target;
        }
    }

    // applies gravity in the approriate directions
    void ApplyGravity()
    {
        deltaX += gravity * gravityDir.x * Time.deltaTime;
        deltaY += gravity * gravityDir.y * Time.deltaTime;
    }

    // switch the facing of the player and the direction the sprite is facing
    private void Flip()
    {
        // Switch the way the player is labelled as facing.
        facingRight = !facingRight;

        /*
        // Multiply the player's x local scale by -1.
        Vector3 theScale = transform.localScale;
        theScale.x *= -1;
        transform.localScale = theScale;
        */
    }

    // sets up our collider
    public void SetCollider(Vector3 size, Vector3 offset)
    {
        collider.size = size;
        collider.offset = offset;

        // scale the values used to set up raycasting
        s = size * colliderScale;
        o = offset * colliderScale;
    }
}
