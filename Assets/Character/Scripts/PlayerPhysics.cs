using UnityEngine;
using System.Collections;

public class PlayerPhysics : MonoBehaviour {

    #region Public Variables
    // Player Movement
    public float gravity = 1.5f;            // force of gravity
    public float maxSpeed = .3f;            // the fastest the player can move
    public float acceleration = 1;          // how fast to interpolate to maxSpeed
    public float jumpHeight = .6f;          // how high can we jump
    //public LayerMask collisionMask;         // what will we collide with
    #endregion

    #region Private Variables
    // Checks
    private bool isGrounded = false;        // are we on the ground
    private bool movementStoppedX = false;  // has our movement forcefully been stopped on the x-axis
    private bool idle = false;              // are we standing still
    private bool facingRight = true;        // what direction are we facing
    private bool canPhase = false;

    // used for movement
    private float deltaX;   // holds all movement in the x-direction
    private float deltaY;   // holds all movement y-direction
    private float hDir;
    private float vDir;

    // holds the direction of gravity
    private Vector2 gravityDir; // (-1 = left || 0 = none || 1 = right, -1 = down || 0 = none || 1 = up)

    //Used to determine if we are near a ground or a ceiling
    private Transform groundCheck;                  // A position marking where to check if the player is grounded.
    private float groundedRadius;     // Radius of the overlap circle to determine if grounded
    // THESE TWO NOT USED FOR NOW, BUT IF WE DID CROUCHING, IT WOULD BE REALLY USEFUL
    private Transform ceilingCheck;                 // A position marking where to check for ceilings
    private const float k_ceilingRadius = .01f;     // Radius of the overlap circle to determine if the player can stand up

    #region Collision Variables
    // used in collisions
    private BoxCollider2D collider; // the box collider on the player
    private Vector2 p;              // our current position
    private Vector3 s;              // the size of our collider
    private Vector3 o;              // the center of our collider

    // used if we have scaled the collider
    private Vector3 originalSize;   // holds the original size of the collider
    private Vector3 originalOffset; // holds the original offset of the collider
    private float colliderScale;    // how much have we scaled by

    // how many rays should we cast for collision detection
    private const int k_collisionsDivisionX = 3;    // number of rays cast for top/bottom collisions
    private const int k_collisionsDivisionY = 3;    // number of rays cast for left/right collisions

    // set this as a global variable so other classes can easily access it for collision calculations
    public static float skin = .005f; // Tiny bit of space above all objects to make sure we stay above them

    // used for all collisions
    private RaycastHit2D hit;   // Holds hit info generated by a Physics2D.Raycast
    #endregion
    #endregion

    void Start()
    {
        gravityDir = new Vector2(0, -1);  // set default gravity to down with no horizontal gravity

        groundCheck = transform.Find("GroundCheck");
        groundedRadius = transform.localScale.x / 2;
        ceilingCheck = transform.Find("CeilingCheck");

        collider = GetComponent<BoxCollider2D>();
        // If we every scale the collider to not be 1,1,1, the below will be useful
        colliderScale = transform.localScale.x; // assumes the scale for the collider is equal in all dimensions
        originalSize = collider.size;
        originalOffset = collider.offset;
        SetCollider(originalSize, originalOffset);
    }

    // On a fixed interval, check if the player is on the ground
    private void FixedUpdate()
    {
        isGrounded = false;

        // The player is grounded if a circlecast to the groundcheck position hits anything designated as ground
        // This can be done using layers instead but Sample Assets will not overwrite your project settings.
        Collider2D[] colliders = Physics2D.OverlapCircleAll(groundCheck.position, groundedRadius, RayLayers.allRays);
        //Debug.DrawLine(new Vector3(groundCheck.position.x - groundedRadius, groundCheck.position.y, groundCheck.position.z - transform.localScale.z/2), new Vector3(groundCheck.position.x + groundedRadius, groundCheck.position.y, groundCheck.position.z - transform.localScale.z / 2));
        for (int i = 0; i < colliders.Length; i++)
        {
            // check if we hit anything that isn't the player and if our vertical speed is 0
            if (colliders[i].gameObject != gameObject && deltaY == 0)
                isGrounded = true;
        }
    }

    // Applies movement to the player based on input
    // @param hDir - the horizontal direction taken in by input
    // @param jump - check if the player has input that they want to jump
    public void Move(float h, float v, bool jump)
    {
        hDir = h;
        vDir = v;

        float targetSpeed = hDir * maxSpeed;        // the speed value we are moving towards, used to handle accelerating the player
        // If we've forcefully be stopped by a collision in the x-direction, reflect that in the actual movement
        if (movementStoppedX)
        {
            targetSpeed = 0;
            deltaX = 0;
        }

        // accelerate the player
        deltaX = IncrementTowards(deltaX, targetSpeed, acceleration);

        // If the input is moving the player right and the player is facing left...
        if (hDir > 0 && !facingRight)
            Flip(); // ...flip the player.
        // Otherwise if the input is moving the player left and the player is facing right...
        else if (hDir < 0 && facingRight)
            Flip(); // ...flip the player.

        // Jump
        if (isGrounded && jump)
        {
            isGrounded = false; // the player is no longer on the ground
            // apply the jump in the appropriate direction according to gravity
            if (gravityDir.x != 0)
                deltaX += jumpHeight * -gravityDir.x;
            if (gravityDir.y != 0)
                deltaY += jumpHeight * -gravityDir.y;
        }

        // if the player is not inputting to move, we are idle
        if (deltaX == 0)
            idle = true;
        else
            idle = false;

        ApplyPhysics();     // apply all physics that would alter movement

        // holds the final transform after all the calculations
        Vector2 finalTransform = new Vector2(deltaX, deltaY);
        // actually move the character
        transform.Translate(finalTransform);
    }

    // apply all physics
    public void ApplyPhysics()
    {
        ApplyGravity();

        HandleCollisions();
    }

    // Handles all collisions
    public void HandleCollisions()
    {
        p = transform.position;

        #region Vertical Collision Detection
        // up
        if (Mathf.Sign(deltaY) == 1)
        {
            for (int i = 0; i < k_collisionsDivisionX; i++)
            {
                                                 // split apart the rays staring from the left of the box to the right of the box
                float x = (p.x + o.x - s.x / 2) + s.x / (k_collisionsDivisionX - 1) * i;
                float y = p.y + o.y + s.y / 2; // top edge of collider

                Vector2 rayOrigin = new Vector2(x, y);  // set the ray's origin point

                // THE FOLLOWING IS USED FOR DEBUGGING
                Ray2D ray = new Ray2D(rayOrigin, new Vector2(0, 1));
                Debug.DrawRay(ray.origin, ray.direction, Color.red);

                // set up our RaycastHit2d
                //@params: the origin we set up earlier
                //         the direction determined by our calculation earlier
                //         only check as far as how far the player would move
                //         the collisionLayerMask
                hit = Physics2D.Raycast(rayOrigin, new Vector2(0, 1), Mathf.Abs(deltaY), RayLayers.upRay);
                //did we generate a hit
                if (hit.fraction > 0)
                {                 
                    // the distance between the raycast and the hit
                    float dst = Vector2.Distance(rayOrigin, hit.point);

                    // Stop vertical movement
                    // If we're very close, but not quite within grace distance, keep moving closer very slowly until we are
                    if (dst > skin)
                        deltaY = dst - skin;
                    else
                        deltaY = 0;

                    isGrounded = true;  // we are on the ground now
                    break;
                }
                // if there's no collision, we're not on a platform
                else
                    transform.parent = null;
            }
        }
        // down
        else if (Mathf.Sign(deltaY) == -1)
        {
            for (int i = 0; i < k_collisionsDivisionX; i++)
            {
                                                 // split apart the rays staring from the left of the box to the right of the box
                float x = (p.x + o.x - s.x / 2) + s.x / (k_collisionsDivisionX - 1) * i;
                float y = p.y + o.y + s.y / 2 * -1; // bottom edge of collider

                Vector2 rayOrigin = new Vector2(x, y);  // set the ray's origin point

                // THE FOLLOWING IS USED FOR DEBUGGING
                Ray2D ray = new Ray2D(rayOrigin, new Vector2(0, -1));
                Debug.DrawRay(ray.origin, ray.direction, Color.red);

                // set up our RaycastHit2d
                //@params: the origin we set up earlier
                //         the direction determined by our calculation earlier
                //         only check as far as how far the player would move
                //         the collisionLayerMask
                hit = Physics2D.Raycast(rayOrigin, new Vector2(0, -1), Mathf.Abs(deltaY), RayLayers.downRay);
                //did we generate a hit
                if (hit.fraction > 0)
                {
                    // assign the moving platform that we're on if we're above one
                    if (hit.collider.tag == "MovingPlatform")
                    {
                        transform.parent = hit.transform;
                    }
                    else
                        transform.parent = null;

                    // is the player on a platform that we can phase through from top to bottom && is the 's' key pressed.
                    if(isGrounded && (hit.collider.gameObject.layer == LayerMask.NameToLayer("SoftTop") || hit.collider.gameObject.layer == LayerMask.NameToLayer("Two-Way")) && vDir == -1)
                    {
                        break;
                    }

                    // the distance between the raycast and the hit
                    float dst = Vector2.Distance(rayOrigin, hit.point);

                    // Stop vertical movement
                    // If we're very close, but not quite within grace distance, keep moving closer very slowly until we are
                    if (dst > skin)
                        deltaY = -dst + skin;
                    else
                        deltaY = 0;

                    isGrounded = true;  // we are on the ground now
                    break;
                }
                // if there's no collision, we're not on a platform
                else
                    transform.parent = null;
            }
        }
        #endregion

        #region Horizontal Collision Detection
        movementStoppedX = false;    // reset movementStopped
        // don't check if we're not moving
        if (deltaX != 0)
        {
            // Check collisions left and right
            for (int i = 0; i < k_collisionsDivisionY; i++)
            {
                float dirX = Mathf.Sign(deltaX); // 1 = right, -1 = left
                float x = p.x + o.x + s.x / 2 * dirX; // left or right edge of collider
                                                      // split apart the rays staring from the top of the box to the bottom of the box
                float y = p.y + o.y - s.y / 2 + s.y / (k_collisionsDivisionY - 1) * i;

                Vector2 rayOrigin = new Vector2(x, y);          // set the ray's origin point

                // THE FOLLOWING IS USED FOR DEBUGGING
                Ray2D ray = new Ray2D(rayOrigin, new Vector2(dirX, 0));
                Debug.DrawRay(ray.origin, ray.direction, Color.red);

                // set up our RaycastHit2d
                //@params: the origin we set up earlier
                //         the direction determined by our calculation earlier
                //         only check as far as how far the player would move
                //         the collisionLayerMask
                hit = Physics2D.Raycast(rayOrigin, new Vector2(dirX, 0), Mathf.Abs(deltaX), RayLayers.allRays);
                //did we generate a hit
                if (hit.fraction > 0)
                {
                    // the distance between the raycast and the hit
                    float dst = Vector2.Distance(rayOrigin, hit.point);

                    // Stop horizontal movement after coming within a grace distance with the collider
                    if (dst > skin)
                        deltaX = dst * dirX - skin * dirX;
                    else
                        deltaX = 0;

                    movementStoppedX = true; // we stopped moving because we hit something
                    break;
                }
            }
        }
        #endregion

        #region Diagonal Collision Detection
        // Check collisions diagonally (to land on edges)
        if (!isGrounded && !movementStoppedX)
        {
            Vector3 playerDir = new Vector3(deltaX, deltaY);    // what direction are we going at the moment
            // find the corner that we're using
            Vector2 center = new Vector2(p.x + o.x + s.x / 2 * Mathf.Sign(deltaX), p.y + o.y + s.y / 2 * Mathf.Sign(deltaY));

            // DRAW THE RAY IN DEBUG
            Debug.DrawRay(center, playerDir.normalized, Color.yellow);

            // normalize because we're using a direction
            // use pythagorean theorem to find the distance of the ray
            if (Physics2D.Raycast(center, playerDir.normalized, Mathf.Sqrt(deltaX * deltaX + deltaY * deltaY), RayLayers.diagonalRays))
            {
                isGrounded = true;
                deltaY = 0;
            }
        }
        #endregion
    }

    // Handles the acceleratation and deceleration of the object
    // @param current - the speed we are currently moving at
    // @param target - the speed we want to be at
    // @param accel - the rate at which we should increment the objects's position
    private float IncrementTowards(float current, float target, float accel)
    {
        // if we're moving at the target speed, we've achieved the speed we wanted
        if (current == target)
            return current;
        else
        {
            // what direction to go to get closer to the target
            float dir = Mathf.Sign(target - current);
            current += accel * Time.deltaTime * dir;
            // if we haven't reached out target speed, return out current speed
            // but if we've gone to far, return the target speed
            return (dir == Mathf.Sign(target - current)) ? current : target;
        }
    }

    // applies gravity in the approriate directions
    void ApplyGravity()
    {
        deltaX += gravity * gravityDir.x * Time.deltaTime;
        deltaY += gravity * gravityDir.y * Time.deltaTime;
    }

    // switch the facing of the player and the direction the sprite is facing
    private void Flip()
    {
        // Switch the way the player is labelled as facing.
        facingRight = !facingRight;

        /*
        // Multiply the player's x local scale by -1.
        Vector3 theScale = transform.localScale;
        theScale.x *= -1;
        transform.localScale = theScale;
        */
    }

    // sets up our collider
    public void SetCollider(Vector3 size, Vector3 offset)
    {
        collider.size = size;
        collider.offset = offset;

        // scale the values used to set up raycasting
        s = size * colliderScale;
        o = offset * colliderScale;
    }
}
